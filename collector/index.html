<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Muggo: Trash Dash</title>
  <style>
    :root{
      --bg1:#0f0c29; /* deep indigo */
      --bg2:#302b63; /* royal violet */
      --bg3:#24243e; /* twilight */
      --accent:#8ef5a0; /* mint glow */
      --accent-2:#6ee7ff; /* cyan glow */
      --warning:#ffbf69; /* warm amber */
      --danger:#ff6b6b; /* coral */
      --fg:#e8f0ff;
      --glass: rgba(255,255,255,0.12);
      --glass-2: rgba(255,255,255,0.08);
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --radius: 18px;
    }
    *{box-sizing:border-box}
    html,body{
      margin:0; height:100%; color:var(--fg);
      background: radial-gradient(1200px 800px at 20% -10%, #3a2f79 0%, transparent 60%),
                  radial-gradient(1000px 700px at 120% 20%, #1b6aa5 0%, transparent 55%),
                  linear-gradient(160deg,var(--bg1),var(--bg2) 50%,var(--bg3));
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
    }
    .wrap{
      max-width: 1100px; margin: 24px auto; padding: 16px; 
    }
    header{
      display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:12px;
    }
    .brand{display:flex; align-items:center; gap:12px}
    .logo{
      width:44px; height:44px; border-radius:12px; display:grid; place-items:center; 
      background: linear-gradient(145deg, var(--accent-2), var(--accent));
      box-shadow: inset 0 0 18px rgba(255,255,255,0.35), var(--shadow);
      color:#00131a; font-weight:900;
    }
    .title{
      line-height:1; font-weight:800; letter-spacing:0.4px; text-shadow: 0 4px 20px rgba(0,0,0,0.45);
    }
    .subtitle{opacity:0.85; font-size:13px}

    .hud{
      display:grid; grid-template-columns: 1fr auto; gap:12px; align-items:center;
      background: linear-gradient( to right, rgba(255,255,255,0.08), rgba(255,255,255,0.04) );
      border:1px solid rgba(255,255,255,0.12);
      border-radius: var(--radius); padding: 12px 14px; box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
    }

    .stats{ display:flex; gap:14px; flex-wrap:wrap }
    .pill{
      display:flex; align-items:center; gap:8px; padding:8px 12px; border-radius: 999px;
      background: var(--glass);
      border:1px solid rgba(255,255,255,0.16);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.12);
      font-weight:700; letter-spacing:0.3px; font-variant-numeric: tabular-nums;
    }
    .pill .k{ opacity:0.8; font-weight:600 }

    .controls{ display:flex; gap:8px; flex-wrap:wrap }
    button, .toggle{
      border:none; cursor:pointer; padding:10px 14px; border-radius: 12px; font-weight:800; letter-spacing:0.3px;
      background: linear-gradient(180deg, rgba(255,255,255,0.16), rgba(255,255,255,0.06));
      border:1px solid rgba(255,255,255,0.2);
      color:var(--fg); box-shadow: var(--shadow);
      transition: transform .08s ease, box-shadow .2s ease, filter .2s ease;
    }
    button.primary{
      background: linear-gradient(180deg, var(--accent), var(--accent-2)); color:#021318;
      text-shadow:none;
    }
    button:active{ transform: translateY(1px) scale(0.99) }
    button:disabled{ opacity:0.6; cursor:not-allowed }

    .game-card{
      position:relative; margin-top:14px; border-radius: var(--radius);
      background: linear-gradient( to bottom right, rgba(255,255,255,0.10), rgba(255,255,255,0.06) );
      border:1px solid rgba(255,255,255,0.14); box-shadow: var(--shadow); overflow:hidden;
    }
    canvas{ width:100%; height:560px; display:block; background: radial-gradient(600px 400px at 30% 10%, rgba(142,245,160,0.06), transparent 60%),
                                    radial-gradient(600px 500px at 90% 80%, rgba(110,231,255,0.06), transparent 65%),
                                    #0a0f1a; }

    .progress{
      height:10px; background: rgba(255,255,255,0.1); border-radius:999px; overflow:hidden;
      margin: 10px 0 0; border:1px solid rgba(255,255,255,0.2);
    }
    .bar{ height:100%; width:100%; background: linear-gradient(90deg, var(--accent), var(--accent-2)); transition: width .3s ease; }

    .overlay{ position:absolute; inset:0; display:grid; place-items:center; pointer-events:none }
    .card{
      pointer-events:auto; background: rgba(10,15,26,0.8); border:1px solid rgba(255,255,255,0.16); border-radius: 16px; padding: 18px; max-width: 520px; text-align:center; box-shadow: var(--shadow); backdrop-filter: blur(8px);
    }
    .card h2{ margin:8px 0 6px }
    .card p{ opacity:0.9 }

    .hidden{ display:none }

    /* Touch controls */
    .touch{
      position:absolute; inset:0; pointer-events:none;
    }
    .pad{ position:absolute; left:16px; bottom:16px; width:120px; height:120px; border-radius:50%; background: rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.2); box-shadow: var(--shadow); pointer-events:auto; touch-action:none }
    .stick{ position:absolute; left:50%; top:50%; width:58px; height:58px; border-radius:50%; transform: translate(-50%,-50%); background: rgba(255,255,255,0.3); border:1px solid rgba(255,255,255,0.35) }
    .dash-btn{ position:absolute; right:16px; bottom:28px; width:120px; height:56px; border-radius:16px; pointer-events:auto; display:grid; place-items:center; background: linear-gradient(180deg, rgba(255,255,255,0.16), rgba(255,255,255,0.06)); border:1px solid rgba(255,255,255,0.2) }

    .footer{
      opacity:0.8; font-size:12px; text-align:center; margin-top:10px
    }
    .kbd{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono"; padding:2px 6px; border-radius:6px; background: rgba(255,255,255,0.12); border:1px solid rgba(255,255,255,0.2) }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="logo">üêæ</div>
        <div>
          <div class="title">Muggo: <span style="color:var(--accent)">Trash Dash</span></div>
          <div class="subtitle">Help Muggo the cat clean up the block. Grab trash, chain combos, be the eco-hero!</div>
        </div>
      </div>
      <div class="controls">
        <button id="startBtn" class="primary">Start</button>
        <button id="pauseBtn">Pause</button>
        <button id="howBtn">How to Play</button>
        <label class="toggle"><input id="muteChk" type="checkbox"/> Mute</label>
      </div>
    </header>

    <div class="hud">
      <div class="stats">
        <div class="pill"><span class="k">Score</span> <span id="score">0</span></div>
        <div class="pill"><span class="k">Combo</span> <span id="combo">x1</span></div>
        <div class="pill"><span class="k">Time</span> <span id="time">60.0</span>s</div>
        <div class="pill"><span class="k">High</span> <span id="high">0</span></div>
      </div>
      <div style="min-width:240px">
        <div class="progress"><div id="bar" class="bar"></div></div>
      </div>
    </div>

    <div class="game-card">
      <canvas id="game" width="960" height="560"></canvas>
      <div id="overlay" class="overlay hidden">
        <div class="card" id="overlayCard"></div>
      </div>
      <div class="touch" id="touch">
        <div class="pad" id="pad"><div class="stick" id="stick"></div></div>
        <div class="dash-btn" id="dashBtn"><span style="font-weight:900; letter-spacing:1px">DASH</span></div>
      </div>
    </div>

    <div class="footer">Keyboard: <span class="kbd">WASD</span> / <span class="kbd">Arrows</span> to move, <span class="kbd">Space</span> to Dash, <span class="kbd">P</span> Pause. Touch: drag left circle, tap Dash.</div>
  </div>

  <script>
  // ===== Utility =====
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a,b) => Math.random()*(b-a)+a;
  const dist2 = (x1,y1,x2,y2) => { const dx=x1-x2, dy=y1-y2; return dx*dx+dy*dy };

  // ===== Audio (WebAudio simple beeps with no external files) =====
  const Sfx = (()=>{
    let ctx;
    let muted = false;
    const ensure = () => { if(!ctx) ctx = new (window.AudioContext||window.webkitAudioContext)() };
    const env = (t0, dur=0.08) => {
      const g = ctx.createGain();
      g.gain.setValueAtTime(0, t0);
      g.gain.linearRampToValueAtTime(0.35, t0+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
      return g;
    };
    const beep = (type='sine', freq=520, dur=0.08, detune=0) => {
      if(muted) return; ensure(); const t=ctx.currentTime;
      const o = ctx.createOscillator(); o.type=type; o.frequency.setValueAtTime(freq,t); o.detune.value = detune;
      const g = env(t,dur);
      o.connect(g).connect(ctx.destination); o.start(t); o.stop(t+dur);
    };
    const chord = (freqs=[440,550], dur=0.12) => { if(muted) return; ensure(); const t=ctx.currentTime; const g=env(t,dur);
      freqs.forEach((f,i)=>{ const o=ctx.createOscillator(); o.type=i? 'triangle':'sine'; o.frequency.setValueAtTime(f,t); o.connect(g); o.start(t); o.stop(t+dur); }); g.connect(ctx.destination);
    };
    return { beep, chord, setMute:(m)=>{ muted=m } };
  })();

  // ===== Game Setup =====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let DPR = window.devicePixelRatio || 1;
  function resize(){
    // Maintain crispness on HiDPI
    const rect = canvas.getBoundingClientRect();
    DPR = window.devicePixelRatio || 1;
    canvas.width = Math.floor(rect.width * DPR);
    canvas.height = Math.floor(rect.height * DPR);
  }
  resize();
  addEventListener('resize', resize);

  // World bounds in canvas pixels
  function bounds(){ return { w: canvas.width, h: canvas.height } }

  // ===== Entities =====
  const world = {
    playing:false,
    paused:false,
    time: 60,
    timeLeft: 60,
    score: 0,
    comboTimer: 0,
    comboMax: 2.8,
    mult: 1,
    maxMult: 5,
    high: Number(localStorage.getItem('muggoTrashDashHigh')||0),
    trash: [],
    puddles: [],
    powerups: [],
    lastSpawn: 0,
    lastPuddle: 0,
    lastPower: 0,
    // New global modifiers
    bonus: 1, // ‚≠ê x2 score temporary
    bonusTimer: 0,
    slowTimer: 0,
    timeScale: 1,
  };

  const keys = {};
  addEventListener('keydown', e=>{
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
    keys[e.key.toLowerCase()] = true;
    if(e.key.toLowerCase()==='p') togglePause();
  });
  addEventListener('keyup', e=>{ keys[e.key.toLowerCase()] = false });

  const player = {
    x: 200, y: 200, r: 20, speed: 210, vx:0, vy:0,
    dash: { cd: 0, cdMax: 1.3, power: 400, time: 0.12 },
    slow: 1,
    magnet: 0, // seconds remaining
    magnetRange: 160, // base attraction range (scaled by DPR)
    boots: 0, // ü•æ ignore puddle slow
  };

  const TRASH_TYPES = [
    { emoji:'üõçÔ∏è', pts: 10 },
    { emoji:'ü•§', pts: 12 },
    { emoji:'üçå', pts: 14 },
    { emoji:'üçæ', pts: 16 },
    { emoji:'üßÉ', pts: 12 },
  ];

  function spawnTrash(){
    const {w,h} = bounds();
    const t = TRASH_TYPES[(Math.random()*TRASH_TYPES.length)|0];
    const r = 15; // pickup radius
    const pad = 30; // edge padding
    let x = rand(pad, w-pad), y = rand(pad, h-pad);
    // avoid spawning right on player
    const safe = 140*140;
    let tries=0;
    while(dist2(x,y, player.x, player.y) < safe && tries < 10){ x=rand(pad,w-pad); y=rand(pad,h-pad); tries++ }
    world.trash.push({ x, y, r, t, born: performance.now() });
  }

  function spawnPuddle(){
    const {w,h} = bounds();
    const r = rand(24,36);
    world.puddles.push({ x: rand(r+20, w-r-20), y: rand(r+20, h-r-20), r, life: rand(8,14) });
  }

  function spawnPower(){
    const {w,h} = bounds();
    // Weighted kinds: more magnets/time, some double/boots/slow-mo
    const kinds = ['magnet','time','double','boots','slowmo'];
    const weights = [0.35,0.25,0.2,0.1,0.1];
    let r = Math.random(); let kind = kinds[0];
    for(let i=0;i<kinds.length;i++){ r -= weights[i]; if(r<=0){ kind = kinds[i]; break } }
    world.powerups.push({ x: rand(40, w-40), y: rand(40, h-40), r: 18, kind, life: 12 });
  }

  function reset(){
    const {w,h}=bounds();
    world.playing = false; world.paused=false; world.timeLeft=world.time; world.score=0; world.mult=1; world.comboTimer=0;
    world.trash.length=0; world.puddles.length=0; world.powerups.length=0; world.lastSpawn=0; world.lastPuddle=0; world.lastPower=0;
    player.x=w*0.5; player.y=h*0.6; player.vx=0; player.vy=0; player.slow=1; player.magnet=0; player.dash.cd=0;
    for(let i=0;i<7;i++) spawnTrash();
    for(let i=0;i<2;i++) spawnPuddle();
  }

  // ===== Drawing =====
  function drawGlowCircle(x,y,r,c1,c2){
    const g = ctx.createRadialGradient(x,y, r*0.1, x,y,r);
    g.addColorStop(0,c1); g.addColorStop(1,c2); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  }

  function drawBackground(){
    const {w,h}=bounds();
    // Grid
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.lineWidth = 1;
    const step = 40 * DPR;
    ctx.beginPath();
    for(let x=0; x<w; x+=step){ ctx.moveTo(x,0); ctx.lineTo(x,h) }
    for(let y=0; y<h; y+=step){ ctx.moveTo(0,y); ctx.lineTo(w,y) }
    ctx.stroke();
    // Ambient blobs
    drawGlowCircle(w*0.18,h*0.2, 160*DPR, 'rgba(110,231,255,0.08)','rgba(110,231,255,0)');
    drawGlowCircle(w*0.82,h*0.78, 180*DPR, 'rgba(142,245,160,0.09)','rgba(142,245,160,0)');
    ctx.restore();
  }

  function drawMuggo(x,y,r){
    // Stylized cat head with Cardano-style dotted eyes
    ctx.save();
    ctx.translate(x,y);
    ctx.shadowColor = 'rgba(110,231,255,0.35)';
    ctx.shadowBlur = 18*DPR;

    // Head
    ctx.fillStyle = '#182331';
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.lineWidth = 2*DPR;
    ctx.beginPath();
    ctx.arc(0,0,r,0,Math.PI*2);
    ctx.fill(); ctx.stroke();

    // Ears
    ctx.beginPath();
    ctx.moveTo(-r*0.4, -r*0.2);
    ctx.lineTo(-r*0.85, -r*0.9);
    ctx.lineTo(-r*0.05, -r*0.55);
    ctx.closePath(); ctx.fill(); ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(r*0.4, -r*0.2);
    ctx.lineTo(r*0.85, -r*0.9);
    ctx.lineTo(r*0.05, -r*0.55);
    ctx.closePath(); ctx.fill(); ctx.stroke();

    // Nose + mouth
    ctx.fillStyle = '#ffbf69';
    ctx.beginPath();
    ctx.arc(0, r*0.22, r*0.07, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.beginPath();
    ctx.moveTo(0, r*0.28); ctx.lineTo(0, r*0.38);
    ctx.moveTo(-r*0.1, r*0.42); ctx.quadraticCurveTo(0,r*0.48, r*0.1, r*0.42);
    ctx.stroke();

    // Eyes (Cardano-like dot constellation)
    function eye(cx){
      const er = r*0.16;
      ctx.fillStyle = '#b7f7ff';
      ctx.beginPath(); ctx.arc(cx, -r*0.05, er*0.42, 0, Math.PI*2); ctx.fill(); // center dot
      const dots = 6;
      for(let i=0;i<dots;i++){
        const ang = (i/dots)*Math.PI*2;
        const rr = er; const dx = Math.cos(ang)*rr; const dy = Math.sin(ang)*rr;
        ctx.beginPath(); ctx.arc(cx+dx, -r*0.05+dy, er*0.16, 0, Math.PI*2); ctx.fill();
      }
    }
    eye(-r*0.35); eye(r*0.35);

    // Whiskers
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.beginPath();
    ctx.moveTo(-r*0.2, r*0.28); ctx.lineTo(-r*0.8, r*0.2);
    ctx.moveTo(-r*0.2, r*0.35); ctx.lineTo(-r*0.8, r*0.35);
    ctx.moveTo(r*0.2, r*0.28); ctx.lineTo(r*0.8, r*0.2);
    ctx.moveTo(r*0.2, r*0.35); ctx.lineTo(r*0.8, r*0.35);
    ctx.stroke();

    ctx.restore();
  }

  function drawTrash(t){
    const time = (performance.now()-t.born)/1000;
    const bob = Math.sin(time*4)*2*DPR;
    ctx.save();
    ctx.font = `${Math.round(24*DPR)}px system-ui, emoji`;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.shadowColor = 'rgba(142,245,160,0.45)'; ctx.shadowBlur = 14*DPR;
    ctx.fillText(t.t.emoji, t.x, t.y + bob);
    ctx.restore();
  }

  function drawPuddle(p){
    ctx.save();
    ctx.globalAlpha = 0.45; ctx.fillStyle = '#1b4c6b';
    drawGlowCircle(p.x,p.y,p.r,'rgba(110,231,255,0.18)','rgba(110,231,255,0)');
    ctx.restore();
  }

  function drawPower(u){
    ctx.save();
    const g = ctx.createLinearGradient(u.x-u.r,u.y-u.r,u.x+u.r,u.y+u.r);
    g.addColorStop(0,'#f9f871'); g.addColorStop(1,'#8ef5a0');
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(u.x,u.y,u.r,0,Math.PI*2); ctx.fill();
    ctx.shadowColor = 'rgba(255,255,255,0.5)'; ctx.shadowBlur=10*DPR;
    ctx.font = `${Math.round(12*DPR)}px ui-sans-serif`; ctx.fillStyle = '#00131a'; ctx.textAlign='center'; ctx.textBaseline='middle';
    const icon = u.kind==='magnet'?'üß≤': u.kind==='time'?'‚è±Ô∏è': u.kind==='double'?'‚≠ê': u.kind==='boots'?'ü•æ':'üåÄ';
    ctx.fillText(icon, u.x, u.y);
    ctx.restore();
  }

  // ===== Mechanics =====
  let last = performance.now();
  function step(){
    const now = performance.now();
    const dt = Math.min(0.033, (now-last)/1000); // clamp for stability
    last = now;
    const dtEff = dt * (world.timeScale||1);

    if(world.playing && !world.paused){
      world.timeLeft -= dt;
      if(world.timeLeft <= 0){ world.timeLeft = 0; endGame(); }

      // Spawns
      world.lastSpawn += dtEff; if(world.lastSpawn > 0.65){ world.lastSpawn=0; if(world.trash.length<24) spawnTrash() }
      world.lastPuddle += dtEff; if(world.lastPuddle > 3.6){ world.lastPuddle=0; if(world.puddles.length<5) spawnPuddle() }
      world.lastPower += dtEff; if(world.lastPower > 7.5){ world.lastPower=0; if(world.powerups.length<3) spawnPower() }

      // Player move
      const accel = (keys['w']||keys['arrowup']? -1:0) + (keys['s']||keys['arrowdown']? 1:0);
      const accer = (keys['a']||keys['arrowleft']? -1:0) + (keys['d']||keys['arrowright']? 1:0);
      let ax = accer, ay = accel;
      // touch input overrides if active
      if(touch.active){ ax = touch.dx; ay = touch.dy }

      const mag = Math.hypot(ax,ay) || 1;
      let vx = (ax/mag) * player.speed * player.slow;
      let vy = (ay/mag) * player.speed * player.slow;

      // dash
      player.dash.cd = Math.max(0, player.dash.cd - dt);
      if((keys[' '] || touch.dash) && player.dash.cd===0){
        // apply burst in current input direction, fallback to last facing
        const dirx = (ax||player.vx||1), diry = (ay||player.vy||0);
        const dmag = Math.hypot(dirx,diry) || 1;
        player.vx = (dirx/dmag) * player.dash.power;
        player.vy = (diry/dmag) * player.dash.power;
        player.dash.cd = player.dash.cdMax;
        Sfx.chord([660,990], 0.12);
        touch.dash = false;
      } else {
        // lerp velocity towards walk speed
        player.vx += (vx - player.vx) * 0.16;
        player.vy += (vy - player.vy) * 0.16;
      }

      player.x += player.vx * dtEff; player.y += player.vy * dtEff;
      const {w,h} = bounds();
      player.x = clamp(player.x, player.r+4, w - player.r-4);
      player.y = clamp(player.y, player.r+4, h - player.r-4);

      // puddles slow
      player.slow = 1;
      if(player.boots<=0){
        for(const p of world.puddles){ if(dist2(player.x,player.y,p.x,p.y) < (player.r+p.r)*(player.r+p.r)) { player.slow = 0.55; break } }
      }

      // Powerup timers
      player.magnet = Math.max(0, player.magnet - dt);
      player.boots = Math.max(0, player.boots - dt);
      world.bonusTimer = Math.max(0, world.bonusTimer - dt);
      if(world.bonusTimer===0) world.bonus = 1;
      world.slowTimer = Math.max(0, world.slowTimer - dt);
      world.timeScale = world.slowTimer>0 ? 0.6 : 1;

      // Trash attraction if magnet
      if(player.magnet>0){
        for(const t of world.trash){
          const dx = player.x - t.x, dy = player.y - t.y; const d = Math.hypot(dx,dy);
          const range = (player.magnetRange||160) * DPR * (player.magnet>5?1.75:1);
          if(d<range){ const f= (1 - d/range)*80; t.x += (dx/d)*f*dtEff; t.y += (dy/d)*f*dtEff }
        }
      }

      // Collect trash
      for(let i=world.trash.length-1;i>=0;i--){
        const t = world.trash[i];
        const r = player.r + t.r;
        if(dist2(player.x,player.y,t.x,t.y) < r*r){
          world.trash.splice(i,1);
          const gain = Math.round(t.t.pts * world.mult * (world.bonus||1));
          world.score += gain;
          world.comboTimer = world.comboMax; // reset combo window
          world.mult = clamp(world.mult + 0.2, 1, world.maxMult);
          Sfx.beep('triangle', 520 + world.mult*40, 0.09);
          // floating text
          floats.push({ x:t.x, y:t.y, text:`+${gain}`, life: 0.8, vx: rand(-20,20), vy: -60 });
        }
      }

      // Powerups
      for(let i=world.powerups.length-1;i>=0;i--){
        const u = world.powerups[i]; u.life -= dtEff; if(u.life<=0){ world.powerups.splice(i,1); continue }
        if(dist2(player.x,player.y,u.x,u.y) < (player.r+u.r)*(player.r+u.r)){
          world.powerups.splice(i,1);
          if(u.kind==='magnet'){ player.magnet = 6; player.magnetRange = 160; floats.push({x:u.x,y:u.y,text:'MAGNET!',life:1.2,vx:0,vy:-40}); Sfx.chord([740,980],0.14) }
          else if(u.kind==='time'){ world.timeLeft = Math.min(world.time, world.timeLeft + 6); floats.push({x:u.x,y:u.y,text:'+6s',life:1.2,vx:0,vy:-40}); Sfx.chord([520,660],0.14) }
          else if(u.kind==='double'){ world.bonus=2; world.bonusTimer=6; floats.push({x:u.x,y:u.y,text:'x2 SCORE!',life:1.2,vx:0,vy:-40}); Sfx.chord([880,1320],0.14) }
          else if(u.kind==='boots'){ player.boots=6; floats.push({x:u.x,y:u.y,text:'PUDDLE BOOTS!',life:1.2,vx:0,vy:-40}); Sfx.chord([600,900],0.14) }
          else if(u.kind==='slowmo'){ world.slowTimer=5; floats.push({x:u.x,y:u.y,text:'SLOW-MO!',life:1.2,vx:0,vy:-40}); Sfx.chord([480,720],0.14) }
        }
      }

      // Puddle lifetimes
      for(let i=world.puddles.length-1;i>=0;i--){ const p=world.puddles[i]; p.life-=dtEff; if(p.life<=0) world.puddles.splice(i,1) }

      // Combo decay
      world.comboTimer = Math.max(0, world.comboTimer - dt);
      if(world.comboTimer===0 && world.mult>1){ world.mult = Math.max(1, Math.floor(world.mult)); world.mult -= 0.1; world.mult = Math.max(1, world.mult) }

      // UI updates
      $score.textContent = world.score;
      $combo.textContent = 'x' + world.mult.toFixed(1).replace(/\.0$/,'');
      $time.textContent = world.timeLeft.toFixed(1);
      $bar.style.width = ((world.timeLeft/world.time)*100).toFixed(1)+'%';
      $high.textContent = world.high;
    }

    // Draw
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBackground();

    world.puddles.forEach(drawPuddle);
    world.trash.forEach(drawTrash);
    world.powerups.forEach(drawPower);

    drawMuggo(player.x, player.y, player.r*DPR);

    // Floating texts
    for(let i=floats.length-1;i>=0;i--){
      const f = floats[i]; f.life -= dt; f.x += f.vx*dt; f.y += f.vy*dt;
      if(f.life<=0) { floats.splice(i,1); continue }
      ctx.save(); ctx.globalAlpha = Math.max(0, f.life/1.2);
      ctx.fillStyle = '#8ef5a0'; ctx.font = `${Math.round(18*DPR)}px ui-sans-serif`; ctx.textAlign='center'; ctx.fillText(f.text, f.x, f.y);
      ctx.restore();
    }

    requestAnimationFrame(step);
  }

  const floats = [];

  function start(){ reset(); world.playing=true; hideOverlay(); Sfx.beep('sine', 740, 0.1); }
  function endGame(){ world.playing=false; if(world.score>world.high){ world.high=world.score; localStorage.setItem('muggoTrashDashHigh', world.high) } showGameOver() }
  function togglePause(){ if(!world.playing) return; world.paused = !world.paused; if(world.paused) showPause(); else hideOverlay() }

  // ===== Overlay / UI =====
  const $overlay = document.getElementById('overlay');
  const $card = document.getElementById('overlayCard');
  const $start = document.getElementById('startBtn');
  const $pause = document.getElementById('pauseBtn');
  const $how = document.getElementById('howBtn');
  const $mute = document.getElementById('muteChk');
  const $score = document.getElementById('score');
  const $combo = document.getElementById('combo');
  const $time = document.getElementById('time');
  const $bar = document.getElementById('bar');
  const $high = document.getElementById('high');

  function showOverlay(html){ $card.innerHTML = html; $overlay.classList.remove('hidden') }
  function hideOverlay(){ $overlay.classList.add('hidden') }

  function showIntro(){
    showOverlay(`
      <h2>Clean the Block with <span style="color:var(--accent)">Muggo</span> üê±</h2>
      <p>Pick up as much trash as you can before time runs out. Chain fast pickups to grow your <b>combo</b> and multiply your score!</p>
      <div style="display:flex; gap:8px; justify-content:center; flex-wrap:wrap; margin-top:10px">
        <span class="pill"><span class="k">Move</span> WASD / Arrows</span>
        <span class="pill"><span class="k">Dash</span> Space</span>
        <span class="pill"><span class="k">Pause</span> P</span>
        <span class=\"pill\"><span class=\"k\">Powerups<\/span> üß≤ Magnet ‚Ä¢ ‚è±Ô∏è +Time ‚Ä¢ ‚≠ê x2 Score ‚Ä¢ ü•æ Boots ‚Ä¢ üåÄ Slow-mo<\/span>
      </div>
      <div style="margin-top:12px; display:flex; gap:8px; justify-content:center">
        <button class="primary" onclick="start()">Start</button>
      </div>
    `);
  }

  function showPause(){
    showOverlay(`
      <h2>Paused ‚è∏Ô∏è</h2>
      <p>Stretch your paws. Combos freeze while paused.</p>
      <div style="margin-top:12px">
        <button class="primary" onclick="togglePause()">Resume</button>
      </div>
    `);
  }

  function rankFor(score){
    if(score>=1200) return 'üåü Trash Titan';
    if(score>=800) return 'üíé Urban Guardian';
    if(score>=500) return 'üßº Eco Cat';
    if(score>=250) return 'üêæ Street Sweeper';
    return 'üå± Eco Kitten';
  }

  function showGameOver(){
    showOverlay(`
      <h2>Time! ‚è∞</h2>
      <p><b>Score:</b> ${world.score} &nbsp;‚Ä¢&nbsp; <b>Rank:</b> ${rankFor(world.score)}</p>
      <p><small>High score: ${world.high}</small></p>
      <div style="margin-top:12px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap">
        <button class="primary" onclick="start()">Play Again</button>
        <button onclick="copyShare()">Share Score</button>
      </div>
    `);
  }

  async function copyShare(){
    const text = `I scored ${world.score} in Muggo: Trash Dash! ${rankFor(world.score)} üê±‚ôªÔ∏è`;
    try{ await navigator.clipboard.writeText(text); $card.insertAdjacentHTML('beforeend', '<p style="opacity:0.8; margin-top:8px">Copied to clipboard. Paste anywhere!</p>') } catch(e){ alert(text) }
  }

  $start.addEventListener('click', start);
  $pause.addEventListener('click', ()=> togglePause());
  $how.addEventListener('click', showIntro);
  $mute.addEventListener('change', e=> Sfx.setMute(e.target.checked));

  showIntro();
  requestAnimationFrame(step);

  // ===== Touch controls =====
  const touch = { active:false, dx:0, dy:0, dash:false };
  const pad = document.getElementById('pad');
  const stick = document.getElementById('stick');
  const dashBtn = document.getElementById('dashBtn');
  let padCenter = {x:0,y:0};
  function updatePadCenter(){ const r = pad.getBoundingClientRect(); padCenter.x = r.left + r.width/2; padCenter.y = r.top + r.height/2 }
  updatePadCenter(); addEventListener('resize', updatePadCenter);

  function padMove(clientX, clientY){
    const dx = clientX - padCenter.x; const dy = clientY - padCenter.y;
    const max = 44; const d = Math.hypot(dx,dy); const m = Math.min(1, d/max);
    // normalize to -1..1, invert Y for canvas
    touch.dx = (dx / (max||1)); touch.dy = (dy / (max||1));
    // clamp
    const cl = d>max ? max/d : 1; const px = dx*cl, py = dy*cl;
    stick.style.transform = `translate(calc(-50% + ${px}px), calc(-50% + ${py}px))`;
  }

  pad.addEventListener('pointerdown', e=>{ touch.active=true; pad.setPointerCapture(e.pointerId); padMove(e.clientX, e.clientY) });
  pad.addEventListener('pointermove', e=>{ if(!touch.active) return; padMove(e.clientX, e.clientY) });
  pad.addEventListener('pointerup', e=>{ touch.active=false; touch.dx=0; touch.dy=0; stick.style.transform='translate(-50%,-50%)' });
  pad.addEventListener('pointercancel', e=>{ touch.active=false; touch.dx=0; touch.dy=0; stick.style.transform='translate(-50%,-50%)' });

  dashBtn.addEventListener('pointerdown', ()=>{ touch.dash = true; setTimeout(()=> touch.dash=false, 80) });

  // Prevent page scroll on spacebar (already prevented in keydown)
  window.onkeydown = function(e){ if(e.keyCode===32 && e.target===document.body){ e.preventDefault(); return false } }
  </script>
</body>
</html>
